#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 32
    bytecblock "status" "client_addr" "escrow_amount" "asset_id" "freelancer_addr" "unitary_price"
    // smart_contracts/digital_marketplace/contract.py:14
    // class DigitalMarketplace(arc4.ARC4Contract):
    pushbytes 0x33b3499e // method "delete_application()void"
    txna ApplicationArgs 0
    match main_delete_application_route@2

main_switch_case_next@3:
    // smart_contracts/digital_marketplace/contract.py:14
    // class DigitalMarketplace(arc4.ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@10
    pushbytess 0xcc760037 0x1574535a 0x790bf59f 0x078fd507 // method "set_price(uint64)void", method "opt_in_to_asset(pay)void", method "buy(pay,uint64)void", method "cancel_job()void"
    txna ApplicationArgs 0
    match set_price opt_in_to_asset buy cancel_job
    err

main_create_NoOp@10:
    // smart_contracts/digital_marketplace/contract.py:14
    // class DigitalMarketplace(arc4.ARC4Contract):
    pushbytes 0x0653b717 // method "create_application(address,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match create_application
    err

main_delete_application_route@2:
    // smart_contracts/digital_marketplace/contract.py:132-133
    // # 6. delete_application (Repurposed for final delete_app)
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete_application


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.create_application[routing]() -> void:
create_application:
    // smart_contracts/digital_marketplace/contract.py:25-29
    // # 1. create_application (Repurposed for create_escrow)
    // @arc4.abimethod(
    //     allow_actions=["NoOp"],
    //     create="require",
    // )
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/digital_marketplace/contract.py:38-39
    // # Pre-Condition: Sender != FREELANCER (arc4.Address object passed as argument is compared directly)
    // assert Txn.sender != freelancer_address
    dig 3
    txn Sender
    !=
    assert
    // smart_contracts/digital_marketplace/contract.py:41-42
    // # Core Action: Set initial parameters and STATUS to PENDING (0)
    // self.client_addr = arc4.Address(Txn.sender)
    bytec_1 // "client_addr"
    txn Sender
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:43
    // self.freelancer_addr = freelancer_address
    bytec 4 // "freelancer_addr"
    uncover 4
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:44
    // self.escrow_amount = escrow_amount
    bytec_2 // "escrow_amount"
    uncover 3
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:45
    // self.asset_id = asset_id
    bytec_3 // "asset_id"
    uncover 2
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:46
    // self.status = UInt64(0)
    bytec_0 // "status"
    intc_0 // 0
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:47
    // self.unitary_price = unitary_price
    bytec 5 // "unitary_price"
    swap
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:25-29
    // # 1. create_application (Repurposed for create_escrow)
    // @arc4.abimethod(
    //     allow_actions=["NoOp"],
    //     create="require",
    // )
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.set_price[routing]() -> void:
set_price:
    // smart_contracts/digital_marketplace/contract.py:49-50
    // # 2. set_price (Kept for template structure but logically unused in escrow)
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/digital_marketplace/contract.py:53
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:54
    // self.unitary_price = unitary_price
    bytec 5 // "unitary_price"
    swap
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:49-50
    // # 2. set_price (Kept for template structure but logically unused in escrow)
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.opt_in_to_asset[routing]() -> void:
opt_in_to_asset:
    // smart_contracts/digital_marketplace/contract.py:56-57
    // # 3. opt_in_to_asset (Repurposed for fund_escrow)
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digital_marketplace/contract.py:63-64
    // # Pre-Condition 1: Status must be PENDING (0)
    // assert self.status == UInt64(0)
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check self.status exists
    !
    assert
    // smart_contracts/digital_marketplace/contract.py:65-66
    // # Pre-Condition 2: Sender must be CLIENT (arc4.Address state variable used directly)
    // assert Txn.sender == self.client_addr
    intc_0 // 0
    bytec_1 // "client_addr"
    app_global_get_ex
    assert // check self.client_addr exists
    dup
    txn Sender
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:68-69
    // # Pre-Condition 3: Atomic Checks (Txn 0 = Payment/Asset Transfer)
    // assert mbr_pay.sender == self.client_addr
    dig 1
    gtxns Sender
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:70
    // assert mbr_pay.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:72-73
    // # Pre-Condition 4: Check Amount (Simplified to ALGO only, ASA_ID=0)
    // assert self.asset_id == UInt64(0)
    intc_0 // 0
    bytec_3 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    !
    assert
    // smart_contracts/digital_marketplace/contract.py:74-75
    // # Client must send escrow_amount + fee buffer for future inner transactions
    // assert mbr_pay.amount >= self.escrow_amount + Global.min_txn_fee
    gtxns Amount
    intc_0 // 0
    bytec_2 // "escrow_amount"
    app_global_get_ex
    assert // check self.escrow_amount exists
    global MinTxnFee
    +
    >=
    assert
    // smart_contracts/digital_marketplace/contract.py:77-78
    // # Core Action: Validates and accepts the funds
    // self.status = UInt64(1) # Sets STATUS to FUNDED (1)
    bytec_0 // "status"
    intc_1 // 1
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:80-82
    // # Inner Transaction: Contract opts into asset (ONLY required if asset_id > 0)
    // # For ALGO (asset_id == 0), no opt-in is needed
    // if self.asset_id > UInt64(0):
    intc_0 // 0
    bytec_3 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    bz opt_in_to_asset_after_if_else@4
    // smart_contracts/digital_marketplace/contract.py:83-88
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=UInt64(0),
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:87
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/digital_marketplace/contract.py:84
    // xfer_asset=self.asset_id,
    intc_0 // 0
    bytec_3 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digital_marketplace/contract.py:85
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/digital_marketplace/contract.py:86
    // asset_amount=UInt64(0),
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digital_marketplace/contract.py:83
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:83-88
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=UInt64(0),
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit

opt_in_to_asset_after_if_else@4:
    // smart_contracts/digital_marketplace/contract.py:56-57
    // # 3. opt_in_to_asset (Repurposed for fund_escrow)
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.buy[routing]() -> void:
buy:
    // smart_contracts/digital_marketplace/contract.py:90-91
    // # 4. buy (Repurposed for approve_work)
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/digital_marketplace/contract.py:98-99
    // # Pre-Condition 1: Sender must be CLIENT
    // assert Txn.sender == self.client_addr
    intc_0 // 0
    bytec_1 // "client_addr"
    app_global_get_ex
    assert // check self.client_addr exists
    txn Sender
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:100-101
    // # Pre-Condition 2: Status must be FUNDED (1)
    // assert self.status == UInt64(1)
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc_1 // 1
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:103-109
    // # Core Action: Transfer FULL escrow amount to freelancer
    // # Fee is paid from the extra buffer funds the client sent
    // itxn.Payment(
    //     receiver=Account(self.freelancer_addr.bytes),
    //     amount=self.escrow_amount,  # Send FULL amount to freelancer
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:108
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/digital_marketplace/contract.py:106
    // receiver=Account(self.freelancer_addr.bytes),
    intc_0 // 0
    bytec 4 // "freelancer_addr"
    app_global_get_ex
    assert // check self.freelancer_addr exists
    dup
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/digital_marketplace/contract.py:107
    // amount=self.escrow_amount,  # Send FULL amount to freelancer
    intc_0 // 0
    bytec_2 // "escrow_amount"
    app_global_get_ex
    assert // check self.escrow_amount exists
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/digital_marketplace/contract.py:103-105
    // # Core Action: Transfer FULL escrow amount to freelancer
    // # Fee is paid from the extra buffer funds the client sent
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:103-109
    // # Core Action: Transfer FULL escrow amount to freelancer
    // # Fee is paid from the extra buffer funds the client sent
    // itxn.Payment(
    //     receiver=Account(self.freelancer_addr.bytes),
    //     amount=self.escrow_amount,  # Send FULL amount to freelancer
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:111
    // self.status = UInt64(2)  # Sets STATUS to COMPLETED (2)
    bytec_0 // "status"
    pushint 2 // 2
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:90-91
    // # 4. buy (Repurposed for approve_work)
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.cancel_job[routing]() -> void:
cancel_job:
    // smart_contracts/digital_marketplace/contract.py:117-118
    // # Pre-Condition 1: Sender must be CLIENT
    // assert Txn.sender == self.client_addr
    intc_0 // 0
    bytec_1 // "client_addr"
    app_global_get_ex
    assert // check self.client_addr exists
    dup
    txn Sender
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:119-120
    // # Pre-Condition 2: Status must be FUNDED (1)
    // assert self.status == UInt64(1)
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc_1 // 1
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:122-128
    // # Core Action: Refund escrow amount to client
    // # Send back escrow_amount only, keep the fee buffer for this transaction
    // itxn.Payment(
    //     receiver=Account(self.client_addr.bytes),
    //     amount=self.escrow_amount,  # Refund FULL escrow amount
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:127
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/digital_marketplace/contract.py:125
    // receiver=Account(self.client_addr.bytes),
    dig 1
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/digital_marketplace/contract.py:126
    // amount=self.escrow_amount,  # Refund FULL escrow amount
    intc_0 // 0
    bytec_2 // "escrow_amount"
    app_global_get_ex
    assert // check self.escrow_amount exists
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/digital_marketplace/contract.py:122-124
    // # Core Action: Refund escrow amount to client
    // # Send back escrow_amount only, keep the fee buffer for this transaction
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:122-128
    // # Core Action: Refund escrow amount to client
    // # Send back escrow_amount only, keep the fee buffer for this transaction
    // itxn.Payment(
    //     receiver=Account(self.client_addr.bytes),
    //     amount=self.escrow_amount,  # Refund FULL escrow amount
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:130
    // self.status = UInt64(3)  # Sets STATUS to CANCELED (3)
    bytec_0 // "status"
    pushint 3 // 3
    app_global_put
    // smart_contracts/digital_marketplace/contract.py:113-114
    // # 5. New Method: cancel_job (Implements cancel_escrow/Refund)
    // @arc4.abimethod()
    intc_1 // 1
    return


// smart_contracts.digital_marketplace.contract.DigitalMarketplace.delete_application[routing]() -> void:
delete_application:
    // smart_contracts/digital_marketplace/contract.py:136-137
    // # Pre-Condition 1: Caller must be CLIENT
    // assert Txn.sender == self.client_addr
    intc_0 // 0
    bytec_1 // "client_addr"
    app_global_get_ex
    assert // check self.client_addr exists
    txn Sender
    ==
    assert
    // smart_contracts/digital_marketplace/contract.py:138-139
    // # Pre-Condition 2: Only callable if STATUS is COMPLETED (2) or CANCELED (3)
    // assert (self.status == UInt64(2)) or (self.status == UInt64(3))
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 2 // 2
    ==
    bnz delete_application_bool_true@3
    intc_0 // 0
    bytec_0 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 3 // 3
    ==
    bz delete_application_bool_false@4

delete_application_bool_true@3:
    intc_1 // 1

delete_application_bool_merge@5:
    // smart_contracts/digital_marketplace/contract.py:138-139
    // # Pre-Condition 2: Only callable if STATUS is COMPLETED (2) or CANCELED (3)
    // assert (self.status == UInt64(2)) or (self.status == UInt64(3))
    assert
    // smart_contracts/digital_marketplace/contract.py:141-149
    // # Core Action: Close the contract account and send ALL remaining balance to client
    // # This includes the MBR and any leftover fee buffer
    // # Use Global.min_txn_fee and ensure contract has enough balance
    // itxn.Payment(
    //     receiver=Account(self.client_addr.bytes),
    //     amount=UInt64(0),
    //     close_remainder_to=Account(self.client_addr.bytes),
    //     fee=Global.min_txn_fee,  # Contract must have 1000 microALGO for this fee
    // ).submit()
    itxn_begin
    // smart_contracts/digital_marketplace/contract.py:148
    // fee=Global.min_txn_fee,  # Contract must have 1000 microALGO for this fee
    global MinTxnFee
    // smart_contracts/digital_marketplace/contract.py:145
    // receiver=Account(self.client_addr.bytes),
    intc_0 // 0
    bytec_1 // "client_addr"
    app_global_get_ex
    assert // check self.client_addr exists
    dup
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    dup
    itxn_field CloseRemainderTo
    // smart_contracts/digital_marketplace/contract.py:146
    // amount=UInt64(0),
    intc_0 // 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/digital_marketplace/contract.py:141-144
    // # Core Action: Close the contract account and send ALL remaining balance to client
    // # This includes the MBR and any leftover fee buffer
    // # Use Global.min_txn_fee and ensure contract has enough balance
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/digital_marketplace/contract.py:141-149
    // # Core Action: Close the contract account and send ALL remaining balance to client
    // # This includes the MBR and any leftover fee buffer
    // # Use Global.min_txn_fee and ensure contract has enough balance
    // itxn.Payment(
    //     receiver=Account(self.client_addr.bytes),
    //     amount=UInt64(0),
    //     close_remainder_to=Account(self.client_addr.bytes),
    //     fee=Global.min_txn_fee,  # Contract must have 1000 microALGO for this fee
    // ).submit()
    itxn_submit
    // smart_contracts/digital_marketplace/contract.py:132-133
    // # 6. delete_application (Repurposed for final delete_app)
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    intc_1 // 1
    return

delete_application_bool_false@4:
    intc_0 // 0
    b delete_application_bool_merge@5
